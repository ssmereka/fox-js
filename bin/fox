#!/usr/bin/env node

/* Fox Script
 * Handles all fox commandline commands.
 * @Author Scott Smereka
 */


//**************************************************
//******************** Load Dependencies
//**************************************************

/***
 * Optimist 
 * @description A library for command option parsing.
 * @repo https://github.com/substack/node-optimist
 * @License MIT/X11
 */
var argv = require('optimist').argv;

/***
 * Lo-Dash 
 * @description A utility library for consitency, customization, and performance.
 * @repo https://github.com/lodash/lodash
 */
var _ = require('lodash');

/***
 * Path
 * @description Handles tranforming file paths.
 * @website http://nodejs.org/api/path.html
 */
var path = require('path');

var wrench = require('wrench'),
    util = require('util');

/***
 * FS
 * @description access the file system
 * @website http://nodejs.org/api/fs.html
 */
var fs = require('fs');

var sys = require('sys');

var childProcess = require('child_process');

var exec = require('child_process').exec;

//**************************************************
//******************** Setup Fox & Globals
//**************************************************

var fox = {};

// Load the fox logger.
fox.log = tryRequire('fox_log.js');

// Load the default backend server configuration.
fox["config"] = tryRequire('config/default_server_config.js');

// If the object could not be loaded, then insert a empty object.
if( ! fox["config"]) {
  fox.log.warn("The default server configuration file could not be loaded.");
  fox["config"] = {}
}

// Absolute path to the fox bin directory.
fox.config["foxBinPath"] = __dirname;

// Absolute path to the fox module root directory.
fox.config["foxPath"] = path.resolve(__dirname, "../");

// Absolute path to the fox server boiler plate directory.
fox.config["foxServerPath"] = path.normalize(fox.config.foxPath + "/server");

// Absolute path to the current user directory.
fox.config["userPath"] = process.cwd();

// Find the path to the current server's directory.
fox.config["serverPath"] = getServerPathSync();

fox.config["cluster"]["workers"] = getNumberOfWorkers(fox.config);

// List of child processes.
var littleChildren = [];


//**************************************************
//******************** Handle Messages
//**************************************************

/**
 * Handle exit from terminal.
 *
 * SIGINT from the terminal is supported on all 
 * platforms, and can usually be generated with 
 * CTRL+C (though this may be configurable). It is 
 * not generated when terminal raw mode is enabled.
 */
process.once("SIGINT", function() {

  // Gracefully kill any children processes
  killChildren();

  // Set a timeout of 5 seconds before force closing.
  setTimeout(function() {
    process.exit(0);
  }, 5000);
});


//**************************************************
//******************** Console Argument Parsing
//**************************************************

// Flag indicating if the user input has been handled.
var isArgvHandled = false,
    isDaemon = false;

// Help - Print fox usage.
if( ! argv._[0] || (_.contains(['help', 'h'], argv._[0]))) {
  printHelp();
  exit();
} 

// Verbose (Debug Mode) - enable or disable debug mode.
if(argv.v || argv.verbose || argv.debug) {
  fox.config["debug"] = true
}

// Environment Mode - set the current operating enviorment mode.
if(argv.l || argv.local) {
  fox.config["environment"] = "local";
} else if(argv.d || argv.dev || argv.development) {
  fox.config["environment"] = "development";
} else if(argv.p || argv.prod || argv.production) {
  fox.config["environment"] = "production";
}

// Start - Start the server
if(argv._[0] && _.contains(['start'], argv._[0])) {
  isArgvHandled = true;

  // Check if server should run in daemon mode.
  if(isDaemonEnabled()) {

    // Check if server should be clustered
    if(isClusterEnabled()) {
      // Start the server using pm2 daemon and cluster.
      startPm2Server(fox.config);
    } else {
      // Start the server using nodemon daemon.
      startNodemanServer(fox.config);
    }
  } else {

    // Start the server using pure node.
    startServer(fox.config);
  }
} 

// Stop - Stop the server
if(argv._[0] && _.contains(['stop'], argv._[0])) {
  isArgvHandled = true;
  stopServer(fox.config);
} 

// Restart - Restart the server gracefully.
if(argv._[0] && _.contains(['restart'], argv._[0])) {
  isArgvHandled = true;
  if(isDaemonEnabled()) {
    restartServer(fox.config);
  }
} 

// Reload - Reload the server with 0 downtime.
if(argv._[0] && _.contains(['reload'], argv._[0])) {
  isArgvHandled = true;
  if(isDaemonEnabled()) {
    restartServerZeroDowntime(fox.config);
  }
} 

// Clear - Stop and remove all server history.
if(argv._[0] && _.contains(['clear'], argv._[0])) {
  isArgvHandled = true;
  clearServer(fox.config);
} 

// New - Create a new server in the current directory
// with the specified name.
if(argv._[0] && _.contains(['new'], argv._[0])) {
  isArgvHandled = true;
  createNewServer(argv._[1]);
} 

// Kill - Kill an application running on a given port.
if(argv._[0] && _.contains(['kill'], argv._[0])) {
  isArgvHandled = true;
  if( ! argv._[1]) {
    fox.log.info("You must include a port number.\nexample: kill 3000");
    exit();
  }
  exec("sudo kill `sudo lsof -t -i:" + argv._[1] + "`", function(err, stdout, stderr) {
    sys.puts(stdout);
    exit();
  });
}

// Argument is not valid
if ( ! isArgvHandled) {
  fox.log.error("Command has invalid arguments.");
  exit();
}


//**************************************************
//******************** Private Methods
//**************************************************

/**
 * Start the server normally using the "node" command.  
 */
function startServer(config, next) {
  // Setup the arguments required to start the node server.
  var args = [
    config.serverPath
  ];

  // Add our node enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Setup our options to be sent to node.
  var opts = {
    cwd: '.',
    env: env
  };

  // Create a child process running node and pipe 
  // the output and error streams to our current terminal.
  var child = executeCommand("node", args, opts);

  // Add the child process to our list of children.
  littleChildren.push(child);
}

/**
 * Start the server using nodeman allowing the server
 * to restart when a file changes.
 */
function startNodemanServer(config, next) {
  // Setup our nodemon arguments with the server to start,
  // and files to watch for changes.
  var args = [
    config["serverPath"],
    '--watch '+config["serverPath"],
    '--watch '+path.resolve(fox.config["serverPath"], "../configs")
  ];

  // Add our node enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Setup our options to be sent to nodemon.
  var opts = {
    cwd: '.',
    env: env
  };

  // Create a child process running nodemon and pipe 
  // the output and error streams to our current terminal.
  var child = executeCommand("nodemon", args, opts);

  // Send all terminal input into the child process 
  // running nodemon.
  process.stdin.on('data', function(data) {
    child.stdin.write(data);
  });

  // Add child proccess to list of all children processes
  littleChildren.push(child);
}

/**
 * Start the server using pm2 to daemonize the process.  Also 
 * perform any clustering that is needed.
 */
function startPm2Server(config, next) {
  // Arguments for staring the server using pm2.
  var args = [
    "start",
    config.serverPath,
    "-i",
    config.cluster.workers,
    "--name", 
    config.name
  ];

  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to start the server using pm2.
  var opts = {
    cwd: '.',
    env: env
  };

  // Get list of current pm2 servers.
  var jlistProcess = executeCommandForResult("pm2", ["jlist"], { cwd: '.' }, function(err, jlist) {
    if(err) {
      fox.log.error(err);
      exit();
    }

    var isServerRunning = false;
    
    // Convert the list to an array.
    jlist = (jlist) ? JSON.parse(jlist) : undefined;

    // Check if the server is already running.
    if(jlist !== undefined && jlist instanceof Array && jlist.length > 0) {
      for(var i = jlist.length-1; i >= 0; --i) {
        if(jlist[i]["name"] === config.name && jlist[i]["pm2_env"]["status"] === "online") {
          fox.log.error("Server " + config.name + " is already started.");
          isServerRunning = true;
        }
      }
    }

    // If the server is not running, start it
    if( ! isServerRunning) {
      var startProcess = executeCommand("pm2", args, opts, next);
    }
  });
}

/**
 * Stop the server.  If the server encounters an error
 * trying to stop, log it, and send the results to the 
 * callback function.
 */
function stopServer(config, next) {
  var opts = {
    cwd: '.',
    env: process.env
  };
  var stopProcess = executeCommand("pm2", ["stop", config.name], opts, next);
}

/**
 * Gracefully restart the server in deamon mode.
 */
function restartServer(config, next) {
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to restart the server using pm2.
  var opts = {
    cwd: '.',
    env: env
  };

  // Restart the named servers gracefully.
  var restartProcess = executeCommand("pm2", ["gracefulReload", config.name], opts, next);
}

/**
 * Reload the server with zero down time.
 * This will preserve the existing connections and reload 
 * each worker one by one.
 * Note:  This will not do a gracefull shutdown.
 */
function restartServerZeroDowntime(config, next) {
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to reload the server using pm2.
  var opts = {
    cwd: '.',
    env: env
  };

  // Reload the named servers with zero down time..
  var reloadProcess = executeCommand("pm2", ["reload", config.name], opts, next);
}

/**
 * Clear all logs.
 */
function clearServerLogs(config, next) {
  console.log("Clear server logs");
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to flush the pm2 logs.
  var opts = {
    cwd: '.',
    env: env
  };

  // Flush the logs from pm2
  var flushProcess = executeCommand("pm2", ["flush"], opts, next);
}

/**
 * Delete all servers from pm2.
 */
function deleteServersFromPm2(config, next) {
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to flush the pm2 logs.
  var opts = {
    cwd: '.',
    env: env
  };

  // Delete the named servers with from pm2.
  var deleteProcess = executeCommand("pm2", ["delete", config.name], opts, next);
}

/**
 * Clear and remove all current tracking of the server.
 */
function clearServer(config, next) {
  stopServer(config, function(err) {
    clearServerLogs(config, function(err) {
      deleteServersFromPm2(config, next);
    });
  });
}

/**
 * Create a new server.
 */
function createNewServer(name) {
  var newServerPath = path.normalize(fox.config.userPath + "/" + name);

  // Check if the new server location is taken
  if(fs.existsSync(newServerPath)) {
    fox.log.error("Server already exists at " + newServerPath);
    exit();
  }

  // Check for a collision of server resources.
  if(fox.config.serverPath && fox.config.serverPath.indexOf(fox.config.userPath) !== -1) {

    // Check for index file at current directory
    if(fs.existsSync(path.resolve(newServerPath, "../index.js"))) {
      fox.log.error("Server already exists at " + path.resolve(newServerPath, "../index.js"));
      exit();
    }

    var serverSplitPath = fox.config.serverPath.replace(fox.config.userPath, "").split(path.sep);

    if(serverSplitPath[1] === "name" || serverSplitPath[1] === "app") {
      fox.log.error("Server already exists at " + fox.config.serverPath);
      exit();
    }
  }

  fox.log.info("Creating " + name + "...");
  wrench.copyDirSyncRecursive(fox.config.foxServerPath, newServerPath, {
    forceDelete: true, 
    preserveFiles: true, 
    inflateSymlinks: false, 
    excludeHiddenUnix: true
  });

  fox.log.info("Configuring...");

  fox.log.info("Installing modules...");
  exec("npm --prefix " + newServerPath + " install", function(err, stdout, stderr) {
    //TODO:  Output this to log file.
    fox.log.success("Server " + name + " created successfully.");
    exit();
  });
}


/**
 * Execute a command in a child process and return the 
 * output and/or error of that process.
 */
function executeCommandForResult(command, args, options, end) {
  var child = childProcess.spawn(command, args, options);
  var output = "";
  var err = "";
  child.stdout.on('data', function(data) {
    if(data) {
      output += data.toString();
    }
  });
  child.stderr.on('data', function(data) {
    if(data) {
      err += data.toString();
    }
  });
  child.on('close', function(code) {
    if(end) {
      end(err, output);
    }
  });
}

/**
 * Execute a command in a child process, then return that process.
 * The child process's standard error and output will
 * be sent to the current terminal.
 */
function executeCommand(command, args, options, end) {
  var child = childProcess.spawn(command, args, options);
  child.stdout.on('data', function(data) {
    process.stdout.write("" + data);
  });
  child.stderr.on('data', function(data) {
    process.stderr.write("" + data);
  });
  child.on('close', function(code) {
    if(end) {
      end(code);
    }
  });
  return child;
}


/**
 * Print the fox script's usage.
 */
function printHelp() {
  fox.log.info("Usage:  fox <command> <options>\n");
  fox.log.info("Commands:");
  printColumns("new <name>", "Create a new server with a specified name.");
  printColumns("start", "Start the server.");
  printColumns("stop", "Stop the server.");
  printColumns("restart", "Restart the server.");
  printColumns("reload", "Restart the server with zero downtime.");
  printColumns("clear", "Stop the server and clear all logs and history.\n");

  fox.log.info("Options:")
  printColumns("-v", "Enable verbose or debug mode.");
  printColumns("-l", "Start in local environment mode.");
  printColumns("-d", "Start in development environment mode.");
  printColumns("-p", "Start in production environment mode.\n");
  exit();
}

/**
 * Print two strings in two different columns in a format much
 * like a word on the left and the definition on the right.
 */
function printColumns(left, right) {
  left = (!left) ? "" : left;
  right = (!right) ? "" : right;
  
  var n = 25 - left.length;
  fox.log.info("  " + left + Array(n+1).join(" ") + right);
}

/**
 * Finds the absolute path to the server application's
 * directory synchronously and returns that value.
 */
function getServerPathSync() {
  var currentDir = fox.config.userPath,
      grandParentDir = path.normalize(currentDir + "/server/app"),
      parentDir = path.normalize(currentDir + "/app");

  if(fs.existsSync(currentDir + "/index.js")) {
    return currentDir;
  } else if (fs.existsSync(parentDir + "/index.js")) {
    return parentDir;
  } else if(fs.existsSync(grandParentDir + "/index.js")) {
    return grandParentDir;
  } else {
    return undefined;
  }
}

/**
 * Attempts to require a file by name synchronously.  This
 * method will do a small, but smart search for the file 
 * and require it.  If the file is not found, then undefined 
 * is returned.
 */
function tryRequire(file) {
  if( ! file) {
    return undefined;
  }

  file = (file.charAt(0) != '/') ? '/' + file : file;
  var currentDirectory = "." + file;
  var binDirectory = path.resolve(__dirname, file);

  if(fs.existsSync(currentDirectory)) {
    return require(currentDirectory);
  } else if(fs.existsSync(binDirectory)) {
    return require(binDirectory);
  } else {
    return require(currentDirectory);
  }
}

/**
 * Check if the server should run in daemon mode or not.
 */
function isDaemonEnabled() {
  if(fox && fox.config && fox.config.daemon !== undefined) {
    return fox.config.daemon;
  } else {

    // Default daemon to enabled.
    return true;
  }
}

/**
 * Check if the server should run in a cluster or not.
 */
function isClusterEnabled() {
  if(fox && fox.config && fox.config.cluster && fox.config.cluster.enabled !== undefined) {
    return fox.config.cluster.enabled;
  } else {

    // Default cluster to disabled.
    return false;
  }
}

/**
 * Get the number of workers to create based on the 
 * configuration options.
 */
function getNumberOfWorkers(config) {
  var isCluster = (config["cluster"] && config.cluster.enabled);
  if(isCluster) {
    var cpuCount = require('os').cpus().length;
    var workerMax = (config.cluster["workerMax"]) ? config.cluster.workerMax : cpuCount;
    
    // Determine the number of workers to create based 
    // on the number of CPUs and the max number of workers.
    var workerCount = (config.cluster["workerPerCpu"] && cpuCount <= workerMax) ? cpuCount : workerMax;

    return (workerCount == cpuCount) ? "max" : workerCount;
  } else {
    return 1;
  }
}

/**
 * Kill all child processes gracefully, then 
 * proceed with exiting or the callback.
 */
function killChildren(signal, end, index) {
  // Default to the front of the child list.
  index = (index === undefined) ? 0 : index;
  // Default to sending a SIGINT.
  signal = (signal === undefined) ? "SIGINT" : signal;

  // Check if killing the last child in the list.
  if(index === littleChildren.length-1) {
    // Default to ending the main process if a callback
    // is not provided.
    end = (end) ? end : function() { exit(); };
    
    // Kill the child and make a call to the callback.
    killChild(littleChildren[index], signal, end);
  } else {
    // Kill the child process and move on to the next child in the list.
    killChild(littleChildren[index], signal, killChildren(signal, end, ++index));
  }
}

/**
 * Kill a child process sending the requrested
 * signal.  Once the child is killed, it make a 
 * call to the callback.
 */
function killChild(child, signal, next) {
  // Event so child makes a call to the next
  // callback after closing.
  child.once('close', function(code) {
    if(next) {
      next();
    }
  });

  // Kill the child process with the specified signal.
  process.kill(child.pid, signal);
}

/**
 * Exit this script with success or a specific error code.
 */
function exit(code) {
  code = (code) ? code : 1;
  process.exit(code);
}