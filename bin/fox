#!/usr/bin/env node

/* Fox Script
 * Handles CLI commands.
 * @Author Scott Smereka
 */


//**************************************************
//******************** 3rd Party Modules
//**************************************************

/***
 * Optimist 
 * @description A library for command option parsing.
 * @repo https://github.com/substack/node-optimist
 * @license MIT/X11
 */
var argv = require('optimist').argv;

/***
 * Lo-Dash 
 * @description A utility library for consitency, customization, and performance.
 * @repo https://github.com/lodash/lodash
 * @license MIT
 */
var _ = require('lodash');

/***
 * Wrench
 * @description A utility library for recursive file operations in node.js.
 * @repo https://github.com/ryanmcgrath/wrench-js
 * @license MIT
 */
var wrench = require('wrench');

var request = require('request');

//**************************************************
//******************** Node.JS Core Modules
//**************************************************

/***
 * Path
 * @description Handles tranforming file paths.
 * @website http://nodejs.org/api/path.html
 */
var path = require('path');

/***
 * Utility
 * @stability 4 - API Frozen
 * @description Utility functions in node.js core.
 * @website http://nodejs.org/api/util.html
 */
var util = require('util');

/***
 * FS
 * @stability 3 - Stable
 * @description access the file system
 * @website http://nodejs.org/api/fs.html
 */
var fs = require('fs');

/***
 * Child Process
 * @stability 3 - Stable
 * @description Handle child processes in node.js
 * @website http://nodejs.org/api/child_process.html
 */
var childProcess = require('child_process');


//**************************************************
//******************** Setup Fox & Globals
//**************************************************

var fox = {};

// Load the fox logger.
fox.log = tryRequire('fox_log.js');

// Load the default backend server configuration.
var defaultConfig = tryRequire('config/default_server_config.js');

// If the object could not be loaded, then insert a empty object.
if( ! defaultConfig) {
  fox.log.warn("The default server configuration file could not be loaded.");
  fox["config"] = {}

  // Environment Mode - set the current operating enviorment mode.
  if(argv.l || argv.local) {
    fox.config["environment"] = "local";
  } else if(argv.d || argv.dev || argv.development) {
    fox.config["environment"] = "development";
  } else if(argv.p || argv.prod || argv.production) {
    fox.config["environment"] = "production";
  }
} else {
  defaultConfig = new defaultConfig();
  // Environment Mode - set the current operating enviorment mode.
  if(argv.n || argv.node) {
    fox["config"] = defaultConfig.node;
  } else if(argv.l || argv.local) {
    fox["config"] = defaultConfig.local;
  } else if(argv.d || argv.dev || argv.development) {
    fox["config"] = defaultConfig.development;
  } else if(argv.p || argv.prod || argv.production) {
    fox["config"] = defaultConfig.production;
  } else {
    fox["config"] = defaultConfig.default;
  }
}

// Absolute path to the fox bin directory.
fox.config["foxBinPath"] = __dirname;

// Absolute path to the fox module root directory.
fox.config["foxPath"] = path.resolve(__dirname, "../");

// Absolute path to the fox server boiler plate directory.
fox.config["foxServerPath"] = path.normalize(fox.config.foxPath + "/server");

// Absolute path to the current user directory.
fox.config["userPath"] = process.cwd();

// Find the path to the current server's directory.
fox.config["serverPath"] = getServerPathSync();

// Make sure there is a cluster configuration object.
fox.config["cluster"] = (fox.config["cluster"]) ? fox.config["cluster"] : {};

// Get the number of workers for a clustered server.
fox.config["cluster"]["workers"] = getNumberOfWorkers(fox.config);

// List of child processes.
var littleChildren = [];


//**************************************************
//******************** Handle Messages
//**************************************************

/**
 * Handle exit from terminal.
 *
 * SIGINT from the terminal is supported on all 
 * platforms, and can usually be generated with 
 * CTRL+C (though this may be configurable). It is 
 * not generated when terminal raw mode is enabled.
 */
process.once("SIGINT", function() {
  // Gracefully kill any children processes
  killChildren();

  // Set a timeout of 5 seconds before force closing.
  setTimeout(function() {
    process.exit(0);
  }, 5000);
});


//**************************************************
//******************** Console Argument Parsing
//**************************************************

// Flag indicating if the user input has been handled.
var isArgvHandled = false;

// Help - Print fox usage.
if( ! argv._[0] || (_.contains(['help', 'h'], argv._[0]))) {
  printHelp();
  exit();
} 

// Verbose (Debug Mode) - enable or disable debug mode.
if(argv.v || argv.verbose || argv.debug) {
  fox.config["debug"] = true
}

// Start - Start the server
if(argv._[0] && _.contains(['start'], argv._[0])) {
  isArgvHandled = true;

  // Check for a controller type.
  var controllerType = (fox.config["controller"]) ? fox.config["controller"] : undefined;

  if(controllerType === 'node') {
    if( ! isDaemonEnabled()) {
      // Start the server using pure node.
      startServer(fox.config);
    } else {
      // TODO: Add ability to start node using a daemon and cluster.
      if(isClusterEnabled()) {
        fox.log.error("Starting node using a cluster is not yet supported.");
      }
      fox.log.error("Starting node in daemon mode is not yet supported.");
    }
  } else if (controllerType === 'nodemon') {
    if( ! isDaemonEnabled()) {
      // Start the server using nodemon daemon.
      startNodemanServer(fox.config);
    } else {
      // TODO: Add ability to start nodemon using a daemon and cluster.
      if(isClusterEnabled()) {
        fox.log.error("Starting nodemon using a cluster is not yet supported.");
      }
      fox.log.error("Starting nodemon in daemon mode is not yet supported.");
    }
  } else if (controllerType === 'pm2') {
    if( ! isDaemonEnabled()) {
      fox.log.error("PM2 must be run as a daemon.");
      exit();
    } else {
      if( ! isClusterEnabled()) {
        var pm2Config = fox.config;
        pm2Config.cluster["workers"] = 1;
        
        // Start the server using pm2 daemon and cluster of 1.
        startPm2Server(pm2Config);
      } else {
        // Start the server using pm2 daemon and cluster.
        startPm2Server(fox.config);
      }
    }
  } else {
    fox.log.error("Controller type of '" + controllerType +"' is unrecognized.");
    exit();
  }
} 

// Stop - Stop the server
if(argv._[0] && _.contains(['stop'], argv._[0])) {
  isArgvHandled = true;
  stopServer(fox.config);
} 

// Restart - Restart the server gracefully.
if(argv._[0] && _.contains(['restart'], argv._[0])) {
  isArgvHandled = true;
  if(isDaemonEnabled()) {
    restartServer(fox.config);
  }
} 

// Reload - Reload the server with 0 downtime.
if(argv._[0] && _.contains(['reload'], argv._[0])) {
  isArgvHandled = true;
  if(isDaemonEnabled()) {
    restartServerZeroDowntime(fox.config);
  }
} 

// Clear - Stop and remove all server history.
if(argv._[0] && _.contains(['clear'], argv._[0])) {
  isArgvHandled = true;
  clearServer(fox.config);
} 

// New - Create a new server in the current directory
// with the specified name.
if(argv._[0] && _.contains(['new'], argv._[0])) {
  isArgvHandled = true;
  createNewServer(argv._[1]);
} 

// Logs - Display a stream of the current server logs.
if(argv._[0] && (_.contains(['log'], argv._[0])) || _.contains(['logs'], argv._[0])) {
  isArgvHandled = true;
  showServerLogs(fox.config);
} 

// Kill - Kill an application running on a given port.
if(argv._[0] && _.contains(['kill'], argv._[0])) {
  isArgvHandled = true;
  if( ! argv._[1]) {
    fox.log.info("You must include a port number.\nexample: kill 3000");
    exit();
  }
  childProcess.exec("sudo kill `sudo lsof -t -i:" + argv._[1] + "`", function(err, stdout, stderr) {
    util.puts(stdout);
    exit();
  });
}

// Argument is not valid
if ( ! isArgvHandled) {
  fox.log.error("Command has invalid arguments.");
  exit();
}


//**************************************************
//******************** Private Methods
//**************************************************

/**
 * Start the server normally using the "node" command.  
 */
function startServer(config, next) {
  // Setup the arguments required to start the node server.
  var args = [
    config.serverPath
  ];

  // Add our node enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Setup our options to be sent to node.
  var opts = {
    cwd: '.',
    env: env
  };

  // Create a child process running node and pipe 
  // the output and error streams to our current terminal.
  var child = executeCommand("node", args, opts);

  // Add the child process to our list of children.
  littleChildren.push(child);
}

/**
 * Start the server using nodeman allowing the server
 * to restart when a file changes.
 */
function startNodemanServer(config, next) {
  // Setup our nodemon arguments with the server to start,
  // and files to watch for changes.
  var args = [
    config["serverPath"],
    '--watch '+config["serverPath"],
    '--watch '+path.resolve(fox.config["serverPath"], "../configs")
  ];

  // Add our node enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Setup our options to be sent to nodemon.
  var opts = {
    cwd: '.',
    env: env
  };

  // Create a child process running nodemon and pipe 
  // the output and error streams to our current terminal.
  var child = executeCommand("nodemon", args, opts);

  // Send all terminal input into the child process 
  // running nodemon.
  process.stdin.on('data', function(data) {
    child.stdin.write(data);
  });

  // Add child proccess to list of all children processes
  littleChildren.push(child);
}

/**
 * Start the server using pm2 to daemonize the process.  Also 
 * perform any clustering that is needed.
 */
function startPm2Server(config, next) {
  // Arguments for staring the server using pm2.
  var args = [
    "start",
    config.serverPath,
    "-i",
    config.cluster.workers,
    "--name", 
    config.name
  ];

  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to start the server using pm2.
  var opts = {
    cwd: '.',
    env: env
  };

  // Get list of current pm2 servers.
  var jlistProcess = executeCommandForResult("pm2", ["jlist"], { cwd: '.' }, function(err, jlist) {
    if(err) {
      if(next) {
        return next(err);
      }
      fox.log.error(err);
      exit();
    }
    
    // Convert the list to an array.
    jlist = (jlist) ? JSON.parse(jlist) : undefined;

    // Check if the server is already running.
    if(jlist !== undefined && jlist instanceof Array && jlist.length > 0) {
      for(var i = jlist.length-1; i >= 0; --i) {
        if(jlist[i]["name"] === config.name && jlist[i]["pm2_env"]["status"] === "online") {
          if(next) {
            return next(new Error("Server " + config.name + " is already started."));
          }
          return fox.log.error("Server " + config.name + " is already started.");
        }
      }
    }

    var startProcess = executeCommand("pm2", args, opts, next);
  });
}

/**
 * Stop the server.  If the server encounters an error
 * trying to stop, log it, and send the results to the 
 * callback function.
 */
function stopServer(config, next) {
  var opts = {
    cwd: '.',
    env: process.env
  };
  var stopProcess = executeCommand("pm2", ["stop", config.name], opts, next);
}

/**
 * Gracefully restart the server in daemon mode.
 */
function restartServer(config, next) {
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to restart the server using pm2.
  var opts = {
    cwd: '.',
    env: env
  };

  // Restart the named servers gracefully.
  var restartProcess = executeCommand("pm2", ["gracefulReload", config.name], opts, next);
}

/**
 * Reload the server with zero down time.
 * This will preserve the existing connections and reload 
 * each worker one by one.
 * Note:  This will not do a gracefull shutdown.
 */
function restartServerZeroDowntime(config, next) {
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to reload the server using pm2.
  var opts = {
    cwd: '.',
    env: env
  };

  // Reload the named servers with zero down time..
  var reloadProcess = executeCommand("pm2", ["reload", config.name], opts, next);
}

function showServerLogs(config, next) {
  // Create the options used to reload the server using pm2.
  var opts = {
    cwd: '.',
    env: process.env
  };

  var startProcess = executeCommand("pm2", ["logs"], opts, function(code) {
    if(next) {
      next();
    }
  });
}


/**
 * Clear all logs.
 */
function clearServerLogs(config, next) {
  fox.log.info("Clearing server logs...");
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to flush the pm2 logs.
  var opts = {
    cwd: '.',
    env: env
  };

  // Flush the logs from pm2
  var flushProcess = executeCommand("pm2", ["flush"], opts, next);
}

/**
 * Delete all servers from pm2.
 */
function deleteServersFromPm2(config, next) {
  // Add the enviorment mode to the current enviorment.
  var env = process.env;
  env["NODE_ENV"] = config.environment;

  // Create the options used to flush the pm2 logs.
  var opts = {
    cwd: '.',
    env: env
  };

  // Delete the named servers with from pm2.
  var deleteProcess = executeCommand("pm2", ["delete", config.name], opts, next);
}

/**
 * Clear and remove all current tracking of the server.
 */
function clearServer(config, next) {
  stopServer(config, function(err) {
    clearServerLogs(config, function(err) {
      deleteServersFromPm2(config, next);
    });
  });
}

/**
 * Create a new server.
 */
function createNewServer(name) {
  var newServerPath = path.normalize(fox.config.userPath + "/" + name);

  // Check if the new server location is taken
  if(fs.existsSync(newServerPath)) {
    fox.log.error("Server already exists at " + newServerPath);
    exit();
  }

  // Check for a collision of server resources.
  if(fox.config.serverPath && fox.config.serverPath.indexOf(fox.config.userPath) !== -1) {

    // Check for index file at current directory
    if(fs.existsSync(path.resolve(newServerPath, "../index.js"))) {
      fox.log.error("Server already exists at " + path.resolve(newServerPath, "../index.js"));
      exit();
    }

    var serverSplitPath = fox.config.serverPath.replace(fox.config.userPath, "").split(path.sep);

    if(serverSplitPath[1] === "name" || serverSplitPath[1] === "app") {
      fox.log.error("Server already exists at " + fox.config.serverPath);
      exit();
    }
  }

  fox.log.info("5. Creating " + name + "...");
  wrench.copyDirSyncRecursive(fox.config.foxServerPath, newServerPath, {
    forceDelete: true, 
    preserveFiles: true, 
    inflateSymlinks: false, 
    excludeHiddenUnix: true
  });

  fox.log.info("4. Configuring...");

  fox.log.info("3. Installing modules...");
  childProcess.exec("npm --prefix " + newServerPath + " install", function(err, stdout, stderr) {

    // Starting server
    fox.log.info("2. Starting server...");
    childProcess.exec("fox start -l", function(err, stdout, stderr) {
      if(err) {
        return fox.log.error(err);
      }

      // Install server database.
      fox.log.info("1. Initalizing database...")
      installServer(generateInstallKey(), function(err){
        if(err) {
          return fox.log.error(err);
        }
        //TODO:  Output this to log file.
        fox.log.info("0. "+name+" created and started successfully.");
      });
    });
  });
}


/**
 * Execute a command in a child process and return the 
 * output and/or error of that process.
 */
function executeCommandForResult(command, args, options, end) {
  var child = childProcess.spawn(command, args, options);
  var output = "";
  var err = "";
  child.stdout.on('data', function(data) {
    if(data) {
      output += data.toString();
    }
  });
  child.stderr.on('data', function(data) {
    if(data) {
      err += data.toString();
    }
  });
  child.on('close', function(code) {
    if(end) {
      end(err, output);
    }
  });
}

/**
 * Execute a command in a child process, then return that process.
 * The child process's standard error and output will
 * be sent to the current terminal.
 */
function executeCommand(command, args, options, end) {
  var child = childProcess.spawn(command, args, options);
  child.stdout.on('data', function(data) {
    process.stdout.write("" + data);
  });
  child.stderr.on('data', function(data) {
    process.stderr.write("" + data);
  });
  child.on('close', function(code) {
    if(end) {
      end(code);
    }
  });
  littleChildren.push(child);
  return child;
}

function installServer(installKey, next) {
  request.post("http://localhost:3001/install.json?access_token="+installKey, {}, function(err, r, body) {
    body = (body) ? JSON.parse(body) : {};
    
    if(body["error"]) {
      return next("("+body["status"]+") "+body["error"]);
    }

    return next(err);
  });
}

function uninstallServer() {
  //TODO: 
}

function generateInstallKey() {
  return "IOlQ9V6Tg6RVL7DSJFL248723Bm3JjCF34FI0TJOVPvRzz";
}

/**
 * Print the fox script's usage.
 */
function printHelp() {
  fox.log.info("Usage:  fox <command> <options>\n");
  fox.log.info("Commands:");
  printColumns("new <name>", "Create a new server with a specified name.");
  printColumns("start", "Start the server.");
  printColumns("stop", "Stop the server.");
  printColumns("restart", "Restart the server.");
  printColumns("reload", "Restart the server with zero downtime.");
  printColumns("clear", "Stop the server and clear all logs and history.");
  printColumns("logs", "Show server logs\n");

  fox.log.info("Options:")
  printColumns("-v", "Enable verbose or debug mode.");
  printColumns("-n", "Start server using plain old node.js and local mode.");
  printColumns("-l", "Start in local environment mode.");
  printColumns("-d", "Start in development environment mode.");
  printColumns("-p", "Start in production environment mode.\n");

  fox.log.info("Info:")
  printColumns("Author", "Scott Smereka");
  printColumns("Version", "0.0.12");
  exit();
}

/**
 * Print two strings in two different columns in a format much
 * like a word on the left and the definition on the right.
 */
function printColumns(left, right) {
  left = (!left) ? "" : left;
  right = (!right) ? "" : right;
  
  var n = 25 - left.length;
  fox.log.info("  " + left + Array(n+1).join(" ") + right);
}

/**
 * Finds the absolute path to the server application's
 * directory synchronously and returns that value.
 */
function getServerPathSync() {
  var currentDir = fox.config.userPath,
      grandParentDir = path.normalize(currentDir + "/server/app"),
      parentDir = path.normalize(currentDir + "/app");

  if(fs.existsSync(currentDir + "/index.js")) {
    return currentDir;
  } else if (fs.existsSync(parentDir + "/index.js")) {
    return parentDir;
  } else if(fs.existsSync(grandParentDir + "/index.js")) {
    return grandParentDir;
  } else {
    return undefined;
  }
}

/**
 * Attempts to require a file by name synchronously.  This
 * method will do a small, but smart search for the file 
 * and require it.  If the file is not found, then undefined 
 * is returned.
 */
function tryRequire(file) {
  if( ! file) {
    return undefined;
  }

  file = (file.charAt(0) != '/') ? '/' + file : file;
  var currentDirectory = "." + file;
  var binDirectory = path.resolve(__dirname, file);

  if(fs.existsSync(currentDirectory)) {
    return require(currentDirectory);
  } else if(fs.existsSync(binDirectory)) {
    return require(binDirectory);
  } else {
    return require(currentDirectory);
  }
}

/**
 * Check if the server should run in daemon mode or not.
 */
function isDaemonEnabled() {
  if(fox && fox.config && fox.config.daemon !== undefined) {
    return fox.config.daemon;
  } else {

    // Default daemon to enabled.
    return false;
  }
}

/**
 * Check if the server should run in a cluster or not.
 */
function isClusterEnabled() {
  if(fox && fox.config && fox.config.cluster && fox.config.cluster.enabled !== undefined) {
    return fox.config.cluster.enabled;
  } else {

    // Default cluster to disabled.
    return false;
  }
}

/**
 * Get the number of workers to create based on the 
 * configuration options.
 */
function getNumberOfWorkers(config) {
  var isCluster = (config["cluster"] && config.cluster.enabled);
  if(isCluster) {
    var cpuCount = require('os').cpus().length;
    var workerMax = (config.cluster["workerMax"]) ? config.cluster.workerMax : cpuCount;
    
    // Determine the number of workers to create based 
    // on the number of CPUs and the max number of workers.
    var workerCount = (config.cluster["workerPerCpu"] && cpuCount <= workerMax) ? cpuCount : workerMax;

    return (workerCount == cpuCount) ? "max" : workerCount;
  } else {
    return 1;
  }
}

/**
 * Kill all child processes gracefully, then 
 * proceed with exiting or the callback.
 */
function killChildren(signal, end, index) {
  // Default to the front of the child list.
  index = (index === undefined) ? 0 : index;
  // Default to sending a SIGINT.
  signal = (signal === undefined) ? "SIGINT" : signal;

  // Check if killing the last child in the list.
  if(index === littleChildren.length-1) {
    // Default to ending the main process if a callback
    // is not provided.
    end = (end) ? end : function() { exit(); };
    
    // Kill the child and make a call to the callback.
    killChild(littleChildren[index], signal, end);
  } else {
    // Kill the child process and move on to the next child in the list.
    killChild(littleChildren[index], signal, killChildren(signal, end, ++index));
  }
}

/**
 * Kill a child process sending the requrested
 * signal.  Once the child is killed, it make a 
 * call to the callback.
 */
function killChild(child, signal, next) {
  // Event so child makes a call to the next
  // callback after closing.
  child.once('close', function(code) {
    if(next) {
      next();
    }
  });

  // Kill the child process with the specified signal.
  process.kill(child.pid, signal);
}

/**
 * Exit this script with success or a specific error code.
 */
function exit(code) {
  code = (code) ? code : 1;
  process.exit(code);
}